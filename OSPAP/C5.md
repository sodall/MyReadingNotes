# C5 Synchronizing Access to Shared Objects
## Cooperating threads
- program execution depends on the possible interleaving sof threads' access to shared state
- program execution can be nondeterministic
  - heisenbugs
  - bohr bugs
- compilers and processor hw can reorder instructions

## Challenges
- race conditions
- atomic operations
- "too much milk" problem:
  - safety
  - liveness
  - Peterson's algorithm
  - memory barriers

## Structuring shared objects
- shared object layer
  - application-specific logic
- synchronization variable layer
  - locks and condition variables
  - coordinate access to state variables
- atomic instruction layer
  - atomic read-modify-write instructions

## Locks
- mutual exclusion
- states: BUSY or FREE
- lock::acquire()
- lock::release()

** Read on page 199 **
